/*
 * Copyright (C) 2009 - 2019 Xilinx, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */

#include <stdio.h>
#include <string.h>
#include "lwip/err.h"
#include "lwip/tcp.h"
#if defined (__arm__) || defined (__aarch64__)
#include "xil_printf.h"
#endif

#include "platform.h"
#include "platform_config.h"
#include "netif/xadapter.h"
#include "xparameters.h"
#include "tcp_server.h"

struct tcp_pcb *tcpb = NULL;
static struct netif server_netif;
struct netif *echo_netif = &server_netif;

extern volatile int TcpFastTmrFlag;
extern volatile int TcpSlowTmrFlag;

void tcp_fasttmr(void);
void tcp_slowtmr(void);
void lwip_init(void);

#if LWIP_IPV6 == 0
static void print_ip(const char *msg, ip_addr_t *ip) {
	xil_printf("%s %d.%d.%d.%d\n\r", msg,
		ip4_addr1(ip), ip4_addr2(ip), ip4_addr3(ip), ip4_addr4(ip));
}

static void print_ip_settings(ip_addr_t *ip, ip_addr_t *mask, ip_addr_t *gw) {
	print_ip("Board IP: ", ip);
	print_ip("Netmask : ", mask);
	print_ip("Gateway : ", gw);
}
#endif


void print_app_header()
{
#if (LWIP_IPV6==0)
	xil_printf("\n\r\n\r-----lwIP TCP server ------\n\r");
#else
	xil_printf("\n\r\n\r-----lwIPv6 TCP server ------\n\r");
#endif
}

void initialize_network()
{
#if LWIP_IPV6==0
	ip_addr_t ipaddr, netmask, gw;
#endif
	unsigned char mac_ethernet_address[] = { 0x00, 0x0a, 0x35, 0x00, 0x01, 0x02 };

	init_platform();
	lwip_init();

#if LWIP_IPV6==0
	xil_printf("Test");
	IP4_ADDR(&ipaddr, 192, 168, 1, 10);
	IP4_ADDR(&netmask, 255, 255, 255, 0);
	IP4_ADDR(&gw, 192, 168, 1, 1);

	if (!xemac_add(echo_netif, &ipaddr, &netmask, &gw, mac_ethernet_address, PLATFORM_EMAC_BASEADDR)) {
		xil_printf("Error adding N/W interface\n\r");
		return;
	}
#else
	if (!xemac_add(echo_netif, NULL, NULL, NULL, mac_ethernet_address, PLATFORM_EMAC_BASEADDR)) {
		xil_printf("Error adding N/W interface\n\r");
		return;
	}
	echo_netif->ip6_autoconfig_enabled = 1;
	netif_create_ip6_linklocal_address(echo_netif, 1);
	netif_ip6_addr_set_state(echo_netif, 0, IP6_ADDR_VALID);
#endif

	netif_set_default(echo_netif);
	netif_set_up(echo_netif);
	platform_enable_interrupts();

	#if LWIP_IPV6 == 0
	print_ip_settings(&echo_netif->ip_addr, &echo_netif->netmask, &echo_netif->gw);
	#endif

}

void process_lwip_events()
{
	if (TcpFastTmrFlag) {
		tcp_fasttmr();
		TcpFastTmrFlag = 0;
	}
	if (TcpSlowTmrFlag) {
		tcp_slowtmr();
		TcpSlowTmrFlag = 0;
	}
	xemacif_input(echo_netif);
}

err_t send_tcp_message(const char *msg)
{
	int len = strlen(msg);
	if (!tcpb || tcpb->state != ESTABLISHED) {
		return ERR_CONN;
	}

	if (tcp_sndbuf(tcpb) >= len) {
		err_t err = tcp_write(tcpb, msg, strlen(msg), TCP_WRITE_FLAG_COPY);
		if (err != ERR_OK) {
			xil_printf("TCP write error: %d\n\r", err);
			return err;
		}
	}
	return tcp_output(tcpb);
}

err_t recv_callback(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err)
{
	if (!p) {
		tcp_close(tpcb);
		tcp_recv(tpcb, NULL);
		return ERR_OK;
	}

	tcp_recved(tcpb, p->len);
	pbuf_free(p);
	tcp_recv(tpcb, NULL);
	return ERR_OK;
}

err_t accept_callback(void *arg, struct tcp_pcb *newpcb, err_t err)
{
	static int connection = 1;
	tcpb = newpcb;
	tcp_recv(newpcb, recv_callback);
	tcp_arg(newpcb, (void*)(UINTPTR)connection);
	connection++;
	return ERR_OK;
}

int start_tcp_server()
{
	struct tcp_pcb *pcb;
	err_t err;
	unsigned port = 7;

	pcb = tcp_new_ip_type(IPADDR_TYPE_ANY);
	if (!pcb) {
		xil_printf("Error creating PCB. Out of Memory\n\r");
		return -1;
	}

	err = tcp_bind(pcb, IP_ANY_TYPE, port);
	if (err != ERR_OK) {
		xil_printf("Unable to bind to port %d: err = %d\n\r", port, err);
		return -2;
	}

	tcp_arg(pcb, NULL);
	pcb = tcp_listen(pcb);
	if (!pcb) {
		xil_printf("Out of memory while tcp_listen\n\r");
		return -3;
	}

	tcp_accept(pcb, accept_callback);
	xil_printf("TCP server started @ port %d\n\r", port);
	return 0;
}
